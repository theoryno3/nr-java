Algorithms from Numerical Recipes, in Java.

The web-site for Numerical Recipes (NR) offers for purchase, as it describes, a third-party contributed, unsupported, set of high-quality Java translations of the C++ code presented in the book, for which they request $95, as part of an all-languages source-code package.  So as far as I can tell, that third-party contributed Java is evidently not available separately at any smaller cost.

The code of the present project is provided free to anyone with no restrictions from me on its use, offered as a labor of love -- of both numerical algorithms and Java.  These are by-hand Java implementations based directly on the algorithms, dew-picked and flown from Mesopotamia, cleansed in finest-quality spring water, lightly killed, and then sealed in a succulent Swiss quintuple smooth treble cream milk chocolate envelope, and lovingly frosted with glucose<sup><a href='http://en.wikipedia.org/wiki/Crunchy_Frog'>1</a></sup>.  And I've made every effort to incorporate those delightful algorithm-clarifying comments.

If price is the measure, I guess I'll say these are "zero-quality" Java implementations.

Everything is as plain-Java as I felt I could make it.  While from a software engineering perspective, the effort by the NR authors to encapsulate (via their `VecDoub`, `MatDoub`, and similar classes) is admirable -- as is the whole template system defined for the purpose -- I doubt that many users, who, upon suddenly realizing, "Gee, I bet that algorithm is in Numerical Recipes!", will come to the NR code already equipped with the abstractions it defines.

So the C++ classes `VecDoub` and friends have become `double[]`, etc.  However there are convenience-classes for objects with by-value semantics ($$), and for formal parameters returned by reference ($).  I tried to make these as concise and painless-to-use as possible.  The convenience-classes are designed to complement existing code from which you might want to call into NR algorithms. Any function parameter that must be transmitted by-reference can be concisely provided via the notation provided, which works for primitive types as well as Java objects.  Since there is no Java-native notion of references or by-value objects in the C++ sense anyway, the use of these utility classes is unlikely to clash with existing client code, and instead should just provide a way for the client code to have access to the NR algorithms in a way that is as close to the C++ exemplars as perhaps may be, which should help to assure users that they are using the algorithms as intended by NR.

Random numbers: there is an issue with the official unsupported Numerical Recipes Java translation sold by NR, here denoted OUNRJ.  In various places throughout the algorithms in NR, the non-support within Java for unsigned integers needs some particular attention.  The most common situation I have come across is the random selection of an item from an array of items, by draw of a random index.  The random functions in NR are able to supply random unsigned integer values, and so for the case of an array of M elements, "int32() % M", for example, is appropriate.  Of course this doesn't work in Java.  The approach in OUNRJ is to add additional random-value functions, ones that only return positive values, called "int32p()" and "int64p()", to the random number generators.  The means by which the positive random values are provided is to draw the signed random values, and then to truncate their higher-order bits.

The issue is that this results in different behavior than the code described in NR.  The equivalent operation to computing the value-modulo-M of an unsigned value x, when representing x as a signed value, and assuming x has the high bit set, would be to compute the signed modulo (ala Java) and if the result is negative, to add M to it.  (Simply using the regular Java modulo of the negative integer produces a negative value, which is pretty undesirable for array indexing.)

However, as is done in the "int32p()" and "int64p()" functions of the random number generators in OUNRJ, truncating the high bit of the drawn random value is equivalent to subtracting, in the case of 4-byte integers, 2147483648 from it, and 9223372036854775808 in the case of 8-byte integers.  If these constants don't happen to be multiples of the modulus M, then the final result after the modulo-M operation will be different than if modulo arithmetic on unsigned values were used, as it is in NR.

In terms of statistical properties of the values drawn, this is probably not an issue.  It does, however, make an exact comparison of behaviors between the original NR and the OUNRJ code difficult.  The random number code in the present project takes the former approach described above, in order to allow exact comparison with the behavior of original NR code.

Provided here is the subset of NR algorithms implemented so far.  Of the 188 unit-tests relevant to the existing code -- unit tests that I don't include since I adapted them from the non-free unit tests offered by NR -- all succeed.

The code covers the algorithms from chapters 1-7,9,15,16,17.  As time allows, I'll do what's left, but I thought that what is here might be useful to someone.

-- Selene